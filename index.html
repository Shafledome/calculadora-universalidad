<!DOCTYPE html>
<html>
    <!-- Serafín Cortés Ramírez
         Universidad de Málaga
         Teoría de Autómatas y Lenguajes Formales
         Enero 2020 
         https://github.com/Shafledome/calculadora-universalidad -->
    <head>
        <title>Calculadora Universalidad - TALF</title>
        <style>
            /* cuerpo */
            body {
                margin: 0;
                font-family: Arial, Helvetica, sans-serif;
            }
            /* Estilo navbar */
            #navbar {
                overflow: hidden;
                background-color: #333;
            }
            /* Enlaces navbar */
            #navbar a {
                float: left;
                display: block;
                color: #f2f2f2;
                text-align: center;
                padding: 14px 16px;
                text-decoration: none;
                font-size: 17px;
            }
            /* hover navbar */
            #navbar a:hover {
                background-color: #ddd;
                color: black;
            }
            /* navbar limpiar */
            #navbar #limpiar {
                background-color: #4CAF50;
                position: relative;
                left: 7.1%;
            }
            /* navbar limpiar hover */
            #navbar #limpiar:hover {
                background-color: #ddd;
                color: black;
            }
            /* contenido */
            .content {
                padding: 16px;
            }
            /* funcion "sticky" se anyade con js */
            .sticky {
                position: fixed;
                top: 0;
                width: 100%;
            }
            /* padding extra para prevenir movimientos rapidos */
            .sticky + .content {
                padding-top: 60px;
            }
        </style>
    </head>
    <body>
        <div class="scroll" style="overflow-y: auto;">
            <center><h1 name="inicio">Calculadora Universalidad</h1></center>
            <center><h2 style="font-weight:normal">Teor&iacute;a de Aut&oacute;matas y Lenguajes Formales</h2></center>
            <center><h3 style="font-weight:normal"><i>Seraf&iacute;n Cort&eacute;s Ram&iacute;rez - Universidad de M&aacute;laga - Enero 2020</i></h3></center>
            <center>
                <h2>ATENCI&Oacute;N:</h2>
                <h3 style="font-weight: normal;">
                    Esta calculadora utiliza el tipo de datos BigInt.<br>
                    Actualmente la librería BigInt no se encuentra nativamente junto a JavaScript en todos los navegadores web, por lo que si tu navegador no posee esta librería, seguramente
                    no te funcionen los c&aacute;lculos.
                </h3>
                <h3>
                    Puedes encontrar <a href="https://caniuse.com/bigint">aqu&iacute;</a> los navegadores en los que se encuentra implementado BigInt nativamente, y a partir de qu&eacute; versi&oacute;n.
                    Compruebalo con la versión de tu navegador.
                </h3>
            </center>
            <br>
            <center>
                <div id="ct2"></div>
                <div id="navbar">
                    <a href="#top" id="inicio">Inicio</a>
                    <a href="#ct2" id="cantorT2">
                        <i>Cantorizaci&oacute;n Tama&ntilde;o 2</i>
                    </a>
                    <a href="#cg" id="cantorG">
                        <i>Cantorizaci&oacute;n Generalizada</i>
                    </a>
                    <a href="#dct2" id="decantorT2">
                        <i>Decantorizaci&oacute;n Tama&ntilde;o 2</i>
                    </a>
                    <a href="#dcg" id="decantorG">
                        <i>Decantorizaci&oacute;n Generalizada</i>
                    </a>
                    <a href="#god" id="codgod">
                        <i>god</i>
                    </a>
                    <a href="#degod" id="coddegod">
                        <i>degod</i>
                    </a>
                    <a href="#codi" id="codcodi">
                        <i>codi</i>
                    </a>
                    <a href="#Codi" id="codCodi">
                        <i>Codi</i>
                    </a>
                    <a href="#CODI" id="codCODI">
                        <i>CODI</i>
                    </a>
                    <a href="#decodi" id="decodecodi">
                        <i>decodi</i>
                    </a>
                    <a href="#DeCodi" id="decoDeCodi">
                        <i>DeCodi</i>
                    </a>
                    <a href="#DECODI" id="decoDECODI">
                        <i>DECODI</i>
                    </a>
                    <a href ="" onclick="limpiarCampos()" id="limpiar">
                        <i>Limpiar Campos</i>
                    </a>
                </div>
                <div id="ct2"></div> <!-- salto antes de cantorizacion t2-->
                <br>
                <br>
                <form name="cantorizacionT2">
                    <h2>
                        Codificaci&oacute;n de Cantor de tama&ntilde;o dos o <i>cantorizaci&oacute;n de tama&ntilde;o dos</i>, 
                        &sigma;<sup style="font-size: 60%;">2</sup><sub style="font-size: 60%;">1</sub>
                    </h2>
                    <h3 style="font-weight: normal">Introduce un n&uacute;mero X y un n&uacute;mero Y, ambos mayores o iguales que 0.</h3>
                    X:&nbsp;&nbsp;<input type="text" size="60" name="x"><br><br>
                    Y:&nbsp;&nbsp;<input type="text" size="60" name="y">
                    <br>
                    <br>
                    <input type="button" value="Calcular" onclick="cantorizacionTam2()">
                    <br>
                    <br>
                    Resultado:&nbsp;&nbsp;<input type="text" size="60" name="cantorizacionTam2Result" readonly>
                </form>
                <div id="cg"></div> <!-- salto antes cantorizacion g-->
                <br>
                <br>
                <form name="cantorizacionGeneral">
                    <h2>
                        Codificaci&oacute;n de Cantor Generalizada o <i>cantorizaci&oacute;n</i>, 
                        &sigma;<sup style="font-size: 60%;">k+1</sup><sub style="font-size: 60%;">1</sub>
                    </h2>
                    <h3 style="font-weight: normal">Introduce todos los valores iguales o mayores que 0 deseados separados por ; y sin espacios.</h3>
                    <i><b>Ejemplo: </b>1;2;3;4</i>
                    <br>
                    <br>
                    <textarea name ="numeros" rows="4" cols="50"></textarea>
                    <br>
                    <br>
                    <input type="button" value="Calcular" onclick="cantorizacionG()">
                    <br>
                    <br>
                    Resultado:&nbsp;&nbsp;<input type="text" size="60" name="cantorizacionGResult" readonly>
                </form>
                <div id="dct2"></div> <!-- salto antes decantorizacion t2-->
                <br>
                <br>
                <form name="decantorizacionT2">
                    <h2>
                        Decodificaci&oacute;n de Cantor de tama&ntilde;o dos o <i>decantorizaci&oacute;n de tama&ntilde;o dos</i>, 
                        (&sigma;<sup style="font-size: 60%;">1</sup><sub style="font-size: 60%;">2,1</sub>,
                        &sigma;<sup style="font-size: 60%;">1</sup><sub style="font-size: 60%;">2,2</sub>)
                    </h2>
                    <h3 style="font-weight: normal;">Introduce un n&uacute;mero mayor o igual que 0.</h3>
                    N&uacute;mero:&nbsp;&nbsp;<input type="text" size="60" name="n">
                    <br>
                    <br>
                    <input type="button" value="Calcular" onclick="decantorizacionTam2()">
                    <br>
                    <br>
                    Resultado:&nbsp;&nbsp;<input type="text" size="60" name="decantorizacionTam2Result" readonly>
                </form>
                <div id="dcg"></div> <!-- salto antes decantorizacion g-->
                <br>
                <br>
                <form name="decantorizacionGeneral">
                    <h2>
                        Decodificaci&oacute;n de Cantor Generalizada o <i>decantorizaci&oacute;n</i>, 
                        (&sigma;<sup style="font-size: 60%;">1</sup><sub style="font-size: 60%;">k+1,i</sub>, . . . , 
                        &sigma;<sup style="font-size: 60%;">1</sup><sub style="font-size: 60%;">k+1,k+1</sub>)
                    </h2>
                    <h3 style="font-weight: normal;">Introduce un n&uacute;mero mayor o igual que 0, y el valor de k tambi&eacute;n mayor que 0.</h3>
                    <i style="font-size: 18px">
                        Recuerda que para k = 2 y i=1, la expresi&oacute;n quedar&iacute;a como:
                        &sigma;<sup style="font-size: 60%;">1</sup><sub style="font-size: 60%;">3,1</sub>
                    </i>
                    <br>
                    <br>
                    N&uacute;mero:&nbsp;&nbsp;<input type="text" size="60" name="n"><br><br>
                    k:&nbsp;&nbsp;<input type="text" size="60" name="k">
                    <br>
                    <br>
                    <input type="button" value="Calcular" onclick="decantorizacionG()">
                    <br>
                    <br>
                    Resultado:&nbsp;&nbsp;<input type="text" size="60" name="decantorizacionGResult" readonly>
                </form>
                <div id="god"></div> <!-- salto antes god-->
                <br>
                <br>
                <form name="codificacionGodel">
                    <h2>
                        Codificaci&oacute;n de G&ouml;del o <i>g&ouml;delizaci&oacute;n</i>, <i>god</i>
                    </h2>
                    <h3 style="font-weight: normal">Introduce todos los valores iguales o mayores que 0 deseados separados por ; y sin espacios.</h3>
                    <i><b>Ejemplo: </b>1;2;3;4</i>
                    <br>
                    <br>
                    <textarea name ="numeros" rows="4" cols="50"></textarea>
                    <br>
                    <br>
                    <input type="button" value="Calcular" onclick="godelizacion()">
                    <br>
                    <br>
                    Resultado:&nbsp;&nbsp;<input type="text" size="60" name="codificacionGodelResult" readonly>
                </form>
                <div id="degod"></div> <!-- salto antes degod-->
                <br>
                <br>
                <form name="decodificacionGodel">
                    <h2>
                        Decodificaci&oacute;n de G&ouml;del o <i>deg&ouml;delizaci&oacute;n</i>, <i>degod</i>
                    </h2>
                    <h3 style="font-weight: normal;">Introduce un n&uacute;mero mayor o igual que 0 <i>(devuelve las k componentes en un vector).</i></h3>
                    N&uacute;mero:&nbsp;&nbsp;<input type="text" size="60" name="n">
                    <br>
                    <br>
                    <input type="button" value="Calcular" onclick="degodelizacion()">
                    <br>
                    <br>
                    Resultado:&nbsp;&nbsp;<input type="text" size="60" name="decodificacionGodelResult" readonly>
                </form>
                <div id="codi"></div> <!-- salto antes codi-->
                <br>
                <br>
                <form name="codificacionSentenciasWhile">
                    <h2>
                        Codificaci&oacute;n de sentencias While o <i>codi</i>
                    </h2>
                    <h3 style="font-weight: normal;">Introduzca la sentencia While a codificar<b> e introduzca ; al final de cada sentencia.</b></h3>
                    <p>Recuerda, las sentencias posibles son:</p>
                    <ul>
                        <li>Xi:= 0;</li>
                        <li>Xi:= Xj;</li>
                        <li>Xi:= Xj+1;</li>
                        <li>Xi:= Xj-1;</li>
                        <li>while Xi!= 0 do S1 od</li>
                    </ul>
                    <p>Donde debes sustituir i y j por el indice de la variable (y S1 siendo el c&oacute;digo dentro del bucle). Los &iacute;ndices de las variables deben de ser mayores que 0.</p>
                    Sentencia o bucle While:
                    <br>
                    <br>
                    <textarea name="sentencia" rows="4" cols="50"></textarea>
                    <br>
                    <br>
                    <input type="button" value="Calcular" onclick="codi()">
                    <br>
                    <br>
                    Resultado:&nbsp;&nbsp;<input type="text" size="60" name="codificacionSentenciasWhileResult" readonly>
                </form>
                <div id="Codi"></div> <!-- salto antes Codi-->
                <br>
                <br>
                <form name="codificacionCodigosWhile">
                    <h2>
                        Codificaci&oacute;n de c&oacute;digos While o <i>Codi</i>
                    </h2>
                    <h3 style="font-weight: normal;">Introduzca el c&oacute;digo While a codificar<b> e introduzca ; al final de cada sentencia.</b></h3>
                    <p>Recuerda, las sentencias posibles son:</p>
                    <ul>
                        <li>Xi:= 0;</li>
                        <li>Xi:= Xj;</li>
                        <li>Xi:= Xj+1;</li>
                        <li>Xi:= Xj-1;</li>
                        <li>while Xi!= 0 do S1 od</li>
                    </ul>
                    <p>Donde debes sustituir i y j por el indice de la variable (y S1 siendo el c&oacute;digo dentro del bucle). Los &iacute;ndices de las variables deben de ser mayores que 0.</p>
                    <b>EJEMPLO:</b><br>
                    <table>
                        <tr><td>X1:=0;<br></td></tr>
                        <tr><td>X1:=X1+1;<br></td></tr>
                        <tr><td>while X1!=0 do<br></td></tr>
                        <tr><td>X2:=X1+1;<br></td></tr>
                        <tr><td>od<br></td></tr>
                    </table>
                    C&oacute;digo While:
                    <br>
                    <br>
                    <textarea name="codigo" rows="4" cols="50"></textarea>
                    <br>
                    <br>
                    <input type="button" value="Calcular" onclick="Codi()">
                    <br>
                    <br>
                    Resultado:&nbsp;&nbsp;<input type="text" size="60" name="codificacionCodigosWhileResult" readonly>
                </form>
                <div id="CODI"></div> <!-- salto antes CODI-->
                <br>
                <br>
                <form name="codificacionProgramasWhile">
                    <h2>
                        Codificaci&oacute;n de programas While o <i>CODI</i>
                    </h2>
                    <h3 style="font-weight: normal;">Introduzca el n&uacute;mero de variables iniciales (n),
                        el n&uacute;mero de variables totales (p) y el c&oacute;digo While a codificar<b> e introduzca ; al final de cada sentencia.</b> p y n deben de ser mayores que 0.</h3>
                    <p>Recuerda, las sentencias posibles son:</p>
                    <ul>
                        <li>Xi:= 0;</li>
                        <li>Xi:= Xj;</li>
                        <li>Xi:= Xj+1;</li>
                        <li>Xi:= Xj-1;</li>
                        <li>while Xi != 0 do S1 od</li>
                    </ul>
                    <p>Donde debes sustituir i y j por el indice de la variable (y S1 siendo el c&oacute;digo dentro del bucle). Los &iacute;ndices de las variables deben de ser mayores que 0.</p>
                    <b>EJEMPLO:</b><br>
                    <table>
                        <tr><td>X1:=0;<br></td></tr>
                        <tr><td>X1:=X1+1;<br></td></tr>
                        <tr><td>while X1!=0 do<br></td></tr>
                        <tr><td>X2:=X1+1;<br></td></tr>
                        <tr><td>od<br></td></tr>
                    </table>
                    n:&nbsp;&nbsp;<input type="text" size="60" name="n"><br><br>
                    p:&nbsp;&nbsp;<input type="text" size="60" name="p"><br><br>
                    C&oacute;digo While:
                    <br>
                    <br>
                    <textarea name="codigo" rows="4" cols="50"></textarea>
                    <br>
                    <br>
                    <input type="button" value="Calcular" onclick="CODI()">
                    <br>
                    <br>
                    Resultado:&nbsp;&nbsp;<input type="text" size="60" name="codificacionProgramasWhileResult" readonly>
                </form>
                <div id="decodi"></div>
                <br>
                <br>
                <form name="decodificacionSentenciasWhile">
                    <h2>
                        Decodificaci&oacute;n de sentencias While o <i>decodi</i>
                    </h2>
                    <h3 style="font-weight: normal;">Introduce un n&uacute;mero mayor o igual que 0.</h3>
                    N&uacute;mero:&nbsp;&nbsp;<input type="text" size="60" name="n">
                    <br>
                    <br>
                    <input type="button" value="Calcular" onclick="decodi()">
                    <br>
                    <br>
                    Resultado:
                    <br>
                    <br>
                    <textarea name="decodificacionSentenciasWhileResult" rows="4" cols="50" readonly></textarea>
                </form>
                <div id="DeCodi"></div>
                <br>
                <br>
                <form name="decodificacionCodigosWhile">
                    <h2>
                        Decodificaci&oacute;n de c&oacute;digos While o <i>DeCodi</i>
                    </h2>
                    <h3 style="font-weight: normal;">Introduce un n&uacute;mero mayor o igual que 0.</h3>
                    N&uacute;mero:&nbsp;&nbsp;<input type="text" size="60" name="n">
                    <br>
                    <br>
                    <input type="button" value="Calcular" onclick="DeCodi()">
                    <br>
                    <br>
                    Resultado:
                    <br>
                    <br>
                    <textarea name="decodificacionCodigosWhileResult" rows="4" cols="50" readonly></textarea>
                </form>
                <div id="DECODI"></div>
                <br>
                <br>
                <form name="decodificacionProgramasWhile">
                    <h2>
                        Decodificaci&oacute;n de programas While o <i>DECODI</i>
                    </h2>
                    <h3 style="font-weight: normal;">Introduce un n&uacute;mero mayor o igual que 0.</h3>
                    N&uacute;mero:&nbsp;&nbsp;<input type="text" size="60" name="numero">
                    <br>
                    <br>
                    <input type="button" value="Calcular" onclick="DECODI()">
                    <br>
                    <br>
                    Resultado:
                    <br>
                    <br>
                    n:&nbsp;&nbsp;<input type="text" size="60" name="n" readonly><br><br>
                    p:&nbsp;&nbsp;<input type="text" size="60" name="p" readonly><br><br>
                    C&oacute;digo While:<br><br>
                    <textarea name="decodificacionProgramasWhileResult" rows="4" cols="50" readonly></textarea>
                </form>
                <br>
                <br>
            </center>
        </div>
    </body>
    <script>
        /*
         * Esta calculadora utiliza la conversion al tipo de datos BigInt
         * Un tipo de datos ahora nativo en JavaScript desde el 2 de diciembre del 2018, fuente: https://github.com/peterolson/BigInteger.js/tree/master
         * Por lo que, en los navegadores Edge, Internet Explorer y Safari es posible que no funcionen las funciones que se encuentran en esta calculadora
         * En Android, funciona en todos los navegadores menos en Safari.
         * Otro problema de usar el tipo BigInt, es que como tipo de dato entero, la parte decimal es truncada, pero para nuestras funciones no es necesario
         * Para escribir un numero BigInt, basta con anyadir n al final (por ejemplo 0n) o invocar al constructor (BigInt(0))
         */
        // funciones para el navbar
        // cuando la pantalla haga scroll, llame a la funcion
        window.onscroll = function() {navbarScroll()};
        // obtiene nuestro navbar
        var navbar = document.getElementById("navbar");
        // obtiene el offset del navbar
        var sticky = navbar.offsetTop;
        // funcion sticky para el desplazamiento del navbar
        function navbarScroll()
        {
            if (window.pageYOffset >= sticky) {
                navbar.classList.add("sticky");
            } else {
                navbar.classList.remove("sticky");
            }
        }
        // funcion para limpiar todos los campos
        function limpiaCampos()
        {
            document.cantorizacionT2.x.value = "";
            document.cantorizacionT2.y.value = "";
            document.cantorizacionT2.cantorizacionTam2Result.value = "";
            document.cantorizacionGeneral.numeros.value = "";
            document.cantorizacionGeneral.cantorizacionGResult.value = "";
            document.decantorizacionT2.n.value = "";
            document.decantorizacionT2.decantorizacionTam2Result.value = "";
            document.decantorizacionGeneral.n.value = "";
            document.decantorizacionGeneral.k.value = "";
            document.decantorizacionGeneral.decantorizacionGResult.value = "";
            document.codificacionGodel.numeros.value = "";
            document.codificacionGodel.codificacionGodelResult.value = "";
            document.decodificacionGodel.n.value = "";
            document.decodificacionGodel.decodificacionGodelResult.value = "";
            document.codificacionSentenciasWhile.sentencia.value = "";
            document.codificacionSentenciasWhile.codificacionSentenciasWhileResult.value = "";
            document.codificacionCodigosWhile.codigo.value = "";
            document.codificacionCodigosWhile.codificacionCodigosWhileResult.value = "";
        }
        // calculo de una raiz cuadrada con BigInt
        function sqrtBI(value)
        {
            if (value < 0n) { // si el valor es menor que 0
                throw "no es posible la raiz de 0";
            }
            if (value < 2n) { // si la raiz es 1
                return value;
            }
            // metodo de newton para la el calculo de la raiz cuadrada
            // metodo de newton https://es.wikipedia.org/wiki/M%C3%A9todo_de_Newton
            // https://golb.hplar.ch/2018/09/javascript-bigint.html
            function newtonIteration(n, x0) {
                const x1 = ((n / x0) + x0) >> 1n;
                if (x0 === x1 || x0 === (x1 - 1n)) {
                    return x0;
                }
                return newtonIteration(n, x1);
            }
            return newtonIteration(value, 1n);
        }
        // funcion cantorizacion tamanyo dos
        // N^2 -> N
        function cantorizacionTam2()
        {
            var x = BigInt(document.cantorizacionT2.x.value); // valor x recogido del formulario html
            var y = BigInt(document.cantorizacionT2.y.value); // valor y recogido del formulario html
            if ((typeof x != 'bigint' || x < 0n) || (typeof y != 'bigint' || y < 0n)) { // si no se ha introducido un numero, x o y no sera de tipo bigint, luego error
                document.cantorizacionT2.cantorizacionTam2Result.value = "";
                alert("Error. \nX e Y deben de ser igual o mayores que 0.")
            } else {
                document.cantorizacionT2.cantorizacionTam2Result.value = cantorizacionTam2Return(x,y); // llamamos a la funcion que realiza los calculos
            }
        }
        // funcion cantorizacion tamanyo dos con return
        function cantorizacionTam2Return(x,y)
        {
            return (x+y)*(x+y+1n)/2n+y; // formula cantorizacion tamanyo dos
        }
        // funcion cantorizacion generalizada
        // N^(k+1) -> N
        function cantorizacionG()
        {
            var numbers = document.cantorizacionGeneral.numeros.value.split(/[;]/); // cogemos el texto escrito en el textarea html y hacemos un array con cada numero separado por ;
            numbers = leeArray(numbers); // funcion que convierte todos los elementos del array a bigint
            for (var i = 0; i < numbers.length; i++) { // si los elementos introducidos no son numeros ya convertidos a bigint, entonces error
                if ((typeof numbers[i] != 'bigint') || numbers[i] < 0n) {
                    document.cantorizacionGeneral.cantorizacionGResult.value = "";
                    alert("Error. \nCompruebe la expresion introducida en la caja de texto y vuelva a intentarlo.");
                    break;
                }
            }
            var result = cantorizacionGRec(numbers); // llamamos a la funcion recursiva que calcula la cantorizacion general
            document.cantorizacionGeneral.cantorizacionGResult.value = result;
        }
        // funcion que convierte todos los elementos del array a bigint
        function leeArray(array) {
            var result = [];
            for (i = 0; i < array.length; i++) {
                var v = BigInt(array[i]);
                if (v < 0n) {
                    document.cantorizacionGeneral.cantorizacionGResult.value = "";
                    alert("Los numeros introducidos deben de ser naturales.");
                    break;
                }
                result[i] = v;
            }
            return result;
        }
        // funcion cantorizacion generalizada recursiva
        function cantorizacionGRec(nums)
        {
            if (nums.length == 1) { // caso base para 1 elemento
                return nums[0];
            } else if (nums.length == 2) { // caso base para 2 elementos
                return cantorizacionTam2Return(nums[0],nums[1]);
            } else {
                var n0 = nums[0];
                nums.shift(); // eliminamos el primer elemento del array, que previamente lo hemos almacenado en n0
                return cantorizacionTam2Return(n0,cantorizacionGRec(nums)); // calculo de forma recursiva
            }
        }
        // funcion decantorizacion tamanyo dos
        // N -> N^2
        function decantorizacionTam2()
        {
            var numero = BigInt(document.decantorizacionT2.n.value); // numero natural recogido del formulario html
            if (typeof numero != 'bigint' || numero < 0n) { // si hemos recibido un elemento que no es un numero, entonces este no habra sido convertido a bigint, error
                document.decantorizacionT2.decantorizacionTam2Result.value = "";
                alert("Error. \nEl numero tiene que ser mayor o igual que 0.")
            } else {
                document.decantorizacionT2.decantorizacionTam2Result.value = decantorizacionTam2Return(numero); // llamamos a la funcion que calcula la decantorizacion de tamanyo dos
            }
        }
        // funcion decantorizacion tamanyo dos con return
        function decantorizacionTam2Return(n)
        {
            return "(" + decantorizacionTam2PrimComp(n) + "," + decantorizacionTam2SegComp(n) + ")"; // llamamos al calculo de cada componente (primera y segunda) de la decantorizacion
        }
        // funcion decantorizacion tamanyo 2 primera componente
        // N -> N
        function decantorizacionTam2PrimComp(n)
        {
            return diagonal(n) - decantorizacionTam2SegComp(n); // calculo de la decantorizacion de tamanyo 2 de la segunda componente
        }
        // funcion decantorizacion tamanyo 2 segunda componente
        // N -> N
        function decantorizacionTam2SegComp(n)
        {
            return n - cantorizacionTam2Return(diagonal(n),0n); // calculo de la decantorizacion de tamanyo 2 de la primera componente
        }
        // funcion diagonal o d(z) siendo z nuestro numero
        // calculado aritmeticamente
        function diagonal(n)
        {
            return (sqrtBI(8n * n + 1n) - 1n) / 2n; // Calculo de la funcion diagonal. BigInt ya realiza truncado de parte decimal
        }
        // funcion decantorizacion generalizada
        // N -> N^k+1
        function decantorizacionG()
        {
            var n = BigInt(document.decantorizacionGeneral.n.value); // numero al que se va a decantorizar
            var kp1 = BigInt(document.decantorizacionGeneral.k.value)+1n; // el usuario introduce el valor de k, puesto que la decantorizacion es en k+1, por ello sumamos uno
            if ((typeof n != 'bigint' || n < 0n ) ||(typeof kp1 != 'bigint' || kp1 < 0n)) { // comprobamos que tenemos un numero convertido a bigint, sino error
                document.decantorizacionGeneral.decantorizacionGResult.value = "";
                alert("Error. \nEl numero y k tienen que ser mayor o igual que 0.")
            } else {
                var result = decantorizacionGReturn(n,kp1); // llamamos a la funcion que nos realiza la composicion de la funcion
                document.decantorizacionGeneral.decantorizacionGResult.value = result.join(''); // la funcion anterior devuelve un array, con join juntamos los elementos a un unico String
            }
        }
        // funcion decantorizacion generalizada return
        function decantorizacionGReturn(n,kp1)
        {
            var result = [];
            result.unshift(")"); // por comodidad, empezamos a rellenar nuestra solucion desde el final, calculando primero la k+1-esima componente de la decantorizacion
            for (var i = kp1; i >= 1n; i--) {
                result.unshift(decantorizacionGRec(n,kp1,i)); // funcion que realiza el calculo de cada componente recursivamente
                result.unshift(",");
            }
            result.shift(); // tras haber anyadido la primera componente, eliminamos la ultima coma introducida, y anyadimos un parentesis
            result.unshift("(");
            return result;
        }
        // funcion decantorizacion generalizada recursiva
        function decantorizacionGRec(n,kp1,i)
        {
            if (kp1 == 1n) { // caso base, si se trata de una decantorizacion de sigma^1 1,1 (N -> N)
                return n;
            } else if (i == 1n) { // caso base, si se trata de la primera componente
                return decantorizacionTam2PrimComp(n);
            } else {
                return decantorizacionGRec(decantorizacionTam2SegComp(n),kp1-1n,i-1n) // calculo recursivo
            }
        }
        // funcion L(x) -> del anexo 3 Codificacion de Godel, del libro: Teoría de Autómatas y Lenguajes Formales, Gonzalo Ramos Jimenez & Rafael Morales Bueno (2011)
        // nuestra funcion L(x) la calculamos como array.length
        // funcion godelizacion
        // N^* -> N
        function godelizacion()
        {
            var error = false; // si se ha producido un error, no modificamos el campo resultado
            // cogemos el texto introducido y separamos por cada ';'. Convertimos a bigint los elementos del array resultante
            var numbers = leeArray(document.codificacionGodel.numeros.value.split(/[;]/)); 
            for (var i = 0; i < numbers.length; i++) {
                if (typeof numbers[i] != 'bigint' || numbers[i] < 0n) { // Comprobamos que todos los elementos introducidos sean validos, sino error
                    error = true;
                    document.codificacionGodel.codificacionGodelResult.value = "";        
                    alert("Error. \nUno de los valores introducidos no es valido.");
                    break;
                }
            }
            if (!error) document.codificacionGodel.codificacionGodelResult.value = godelizacionReturn(numbers); // si no se ha producido error, llamamos a la funcion que realiza el calculo
        }
        // funcion godelizacion return
        function godelizacionReturn(array)
        {
            var result = 0n;
            if (array.length != 0) { // si el array no es de tamanyo 0, hacemos su calculo usando funciones anteriores
                result = cantorizacionTam2Return(BigInt(array.length-1),cantorizacionGRec(array))+1n;
            }
            return result;
        }
        // funcion longitud (dado un z)
        function longitud(z)
        {
            if (z == 0n) { // caso base, si z es 0
                return 0n;
            } else {
                return decantorizacionTam2PrimComp(z-1n)+1n; // calculo de la funcion
            }
        }
        // funcion degodelizacion
        // N^2 -> N
        function degodelizacion()
        {
            var z = BigInt(document.decodificacionGodel.n.value); // cogemos el valor a degodelizar y lo convertimos a bigint
            if (typeof z != 'bigint' || z < 0n) { // si no se ha introducido un numero, error
                document.decodificacionGodel.decodificacionGodelResult.value = "";
                alert("Error. \nEl valor introducido no es valido."); 
            } else {
                var result = [];
                result.unshift(")"); // por comodidad, empezamos a componer la solucion desde el elemento longitud(z)-esimo hasta el primer elemento
                for (var k = longitud(z); k >= 1n; k--) {
                    result.unshift(degodelizacionReturn(z,k)); // llamamos a la funcion que realiza el calculo
                    result.unshift(",");
                }
                result.shift(); // eliminamos la ultima coma introducida y anyadimos un parentesis
                result.unshift("(");
                document.decodificacionGodel.decodificacionGodelResult.value = result.join(''); // juntamos todos los elementos del array solucion en un unico String
            }
        }
        // funcion degodelizacion con return
        function degodelizacionReturn(z,k)
        {
            if (z == 0n || k > longitud(z)) { // caso base si z es 0, o su longitud es 0
                return 0n;
            } else {
                return decantorizacionGRec(decantorizacionTam2SegComp(z-1n),longitud(z),k); // calculo de la funcion
            }
        }
        // funcion tipoLinea, devuelve el tipo de la sentencia while
        function tipoLinea(sentencia) {
            let regexs = [/X.:=0;/g,/X.:=X.;/g,/X.:=X.\+1;/g,/X.:=X.\-1;/g,/while\sX.!=0\sdo\n[^]*\nod/g];
            var result = -1; // si es una sentencia erronea
            for (var i = regexs.length-1; i >= 0; i--) {
                if (regexs[i].test(sentencia) == true) {
                result = i;
                break;
                }
            }
            return result;
        }
        function extraerIndices(sentencia)
        {
            var regex = /([^:=;X\n\+\-]+)/g
            var regexWhile = /(\d+)|^(?!do|;|od)([:=;X\+\-\d+]+)/gm;
            var ti = tipoLinea(sentencia);
            var result;

            switch(ti) {
              case 0:
                result = sentencia.match(regex);
                result.pop(); // eliminamos el 0
                break;
              case 1:
                result = sentencia.match(regex);
                break;
              case 2:
                result = sentencia.match(regex);
                result.pop();
                break;
              case 3:
                result = sentencia.match(regex);
                result.pop();
                break;
              case 4:
                result = sentencia.match(regexWhile);
                break;
            }
            return result;
        }
        // funcion codi de codificacion de sentencias while
        // Cod_While -> N
        function codi()
        {
            var linea = document.codificacionSentenciasWhile.sentencia.value;
            var result = codiReturn(linea);
            if (typeof result == 'bigint') {
                document.codificacionSentenciasWhile.codificacionSentenciasWhileResult.value = result; // si la solucion es un bigint, es correcta
            } else {
                alert("Error. \nCompruebe la expresion introducida en la caja de texto y vuelva a intentarlo.");
            }
        }
        // funcion codi con return
        function codiReturn(sentencia)
        {
            var ti = tipoLinea(sentencia);
            var result;
            var indices = extraerIndices(sentencia);

            switch(ti) {
                case 0:
                  result = 5n*(BigInt(indices[0]-1));
                  break;
                case 1:
                  result = 5n*cantorizacionTam2Return(BigInt(indices[0]-1),BigInt(indices[1]-1))+1n;
                  break;
                case 2:
                  result = 5n*cantorizacionTam2Return(BigInt(indices[0]-1),BigInt(indices[1]-1))+2n;
                  break;
                case 3:
                  result = 5n*cantorizacionTam2Return(BigInt(indices[0]-1),BigInt(indices[1]-1))+3n;
                  break;
                case 4:
                  var ind = indices.slice(2,indices.length);
                  result = 5n*cantorizacionTam2Return(BigInt(indices[0]-1),CodiReturn(ind))+4n;
                  break;
            }
            return result;
        }
        // funcion separar sentencia while
        function tratarLinea(linea)
        {
            return linea.replace(/[\s]/g,'').split(''); // elimina los espacios por la cadena vacia, despues separa todos los elementos
        }
        // funcion Codi con return
        function CodiReturn(indices)
        {
            var result = [];
            for (var i = 0; i < indices.length; i++) {
                result[i] = codiReturn(indices[i]);
            }
            return godelizacionReturn(result)-1n; // godelizamos
        }
        // funcion que separa todas las sentencias del codigo while
        function separarSentencias(lineas)
        {
            var regex = /([:=;X\+\-\d+]+)|(while\sX.!=0\sdo)([^]*)(od)/gm
            
            return lineas.match(regex);
        }
        // funcion Codificacion de codigos
        function Codi()
        {
            var sentencias = separarSentencias(document.codificacionCodigosWhile.codigo.value);
            var result = CodiReturn(sentencias); // llama a la funcion que realiza el calculo
            if (typeof result == 'bigint') { // si el resultado es bigint, es una solucion
                document.codificacionCodigosWhile.codificacionCodigosWhileResult.value = result;
            } else { // sino, es un error
                alert("Error. \nCompruebe la expresion introducida en la caja de texto y vuelva a intentarlo.");
            }
            
        }
        // funcion mayorIndiceCodigo que devuelve el mayor indice de un codigo
        function mayorIndiceCodigo(sentencias)
        {
            var regex = /(X\d)/gm;
            var listaVariables = sentencias.match(regex); // obtenemos la lista de variables

            var regex2 = /\d/g;
            /*var indicesVariables = [];
            for (var i = 0; i < listaVariables.length; i++) {
                indicesVariables[i] = listaVariables[i].match(regex2);
            }*/
            var indicesVariables = listaVariables.map(variable => variable.match(regex2)); // obtenemos la lista de indices

            return Math.max.apply(null, indicesVariables); // devolvemos el mayor
        }
        // funcion Codificacion de programas While
        // CODI: WHILE -> N
        function CODI()
        {
            var n = document.codificacionProgramasWhile.n.value; // obtiene del formulario html el valor de n
            var p = document.codificacionProgramasWhile.p.value; // obtiene del formulario html el valor de p
            var codigo = document.codificacionProgramasWhile.codigo.value; // obtiene el codigo while
            var sentencias = separarSentencias(codigo); // obtiene las sentencias while
            var mIndiceCodigo = mayorIndiceCodigo(codigo);

            if (n <= 0 || p <= 0) { // si n o p son menores o iguales que 0, o no validos
                alert("Error. \np y n deben de ser naturales mayores que 0.");
            } else if (p < n) { // si p es menor que n
                alert("Error. \np debe de ser mayor o igual que n");
            } else if (mIndiceCodigo > p) { // si el mayor indice es mayor que el numero total de variables
                alert("Error. \nEl mayor indice del codigo es mayor que el numero total de variables");
            } else {
                var valores = [];
                valores[0] = BigInt(n);
                valores[1] = BigInt(p-(Math.max(n,mIndiceCodigo)));
                valores[2] = CodiReturn(sentencias);
                var result = cantorizacionGRec(valores);
                if (typeof result != 'bigint') { // si el resultado no es de tipo bigint, es un error
                    alert("Error. \nCompruebe los valores n y p, y el codigo while.");
                } else {
                    document.codificacionProgramasWhile.codificacionProgramasWhileResult.value = result;
                }
            }
        }
        // funcion tipo de sentencia
        // tipo: N -> {0,1,2,3,4}
        function tipo(z)
        {
            if (typeof z != 'bigint') { // si z no fuera de tipo bigint
                return -1;
            } else {
                return z % 5n; // calcula la funcion tipo
            }
        }
        // funcion extraer
        // extr: N x {1,2} -> N
        function extraer(z,i)
        {
            if (i < 1 || i > 2) { // si la variable i fuera menor que 1 o mayor que 2
                alert("Error. \nEl valor de i (variable deseada) solo puede ser 1 (izquierda) o 2 (derecha).");
            } else if (typeof z != 'bigint') { // si z no fuera de tipo bigint
                alert("Error, \nEl valor del numero debe de ser tipo BigInt");
            } else {
                if (tipo(z) == 0) { // caso base, si el tipo de z es 0
                    return 1n+z/5n;
                } else {
                    if (i == 1) { // si se busca la variable izquierda
                        return 1n+decantorizacionTam2PrimComp((z-tipo(z))/5n);
                    } else { // si se busca la variable derecha
                        return 1n+decantorizacionTam2SegComp((z-tipo(z))/5n);
                    }
                }
            }
        }
        // funcion decodificacion de sentencias While
        // decodi: N -> Cod_While
        function decodi()
        {
            var z = BigInt(document.decodificacionSentenciasWhile.n.value); // valor de z convertido a bigint
            var result = decodiReturn(z); // llama a la funcion que realiza los calculos
            document.decodificacionSentenciasWhile.decodificacionSentenciasWhileResult.value = result;
        }
        // funcion decodi con return
        function decodiReturn(z)
        {
            if (typeof z != 'bigint') {
                return -1;
            } else {
                var result = null;
                if (tipo(z) == 0) { // si la sentencia es de tipo 0
                    result = "X" + extraer(z,1) + ":=0;";
                } else if (tipo(z) == 1) { // si la sentencia es de tipo 1
                    result = "X" + extraer(z,1) + ":=X" + extraer(z,2) + ";";
                } else if (tipo(z) == 2) { // si la sentencia es de tipo 2
                    result = "X" + extraer(z,1) + ":=X" + extraer(z,2) + "+1;";
                } else if (tipo(z) == 3) { // si la sentencia es de tipo 3
                    result = "X" + extraer(z,1) + ":=X" + extraer(z,2) + "-1;";
                } else { // si la sentencia es de tipo 4
                    result = "while X" + extraer(z,1) + "!=0 do \n" + DeCodiReturn(extraer(z,2)-1n) + "od";
                }
                return result;
            }
        }
        // funcion decodificacion de codigos While
        // DeCodi: N -> Cod_While
        function DeCodi()
        {
            var z = BigInt(document.decodificacionCodigosWhile.n.value); // valor de z convertido a bigint
            document.decodificacionCodigosWhile.decodificacionCodigosWhileResult.value = DeCodiReturn(z); // llama a la funcion que realiza el calculo
            
        }
        // funcion DeCodi con return
        function DeCodiReturn(z)
        {
            if (typeof z != 'bigint') { // si z no fuera bigint, es un error
                alert("Error. \nEl numero a introducir debe de ser mayor o igual que 0.");
            } else {
                var result = "";
                for (var i = 1n; i < longitud(z); i++) { // desde 1 hasta la longitud de z, calculamos las sentencias
                    result += (decodiReturn(degodelizacionReturn(z+1n,i))); 
                    result += "\n"; // anyadimos un salto de linea al final
            }
            return result;
            }
        }
        // funcion decodificacion de programas While
        // DECODI: N -> WHILE
        function DECODI()
        {
            var z = BigInt(document.decodificacionProgramasWhile.numero.value); // obtiene el valor de z y lo convierte a bigint
            var result = DECODIReturn(z); // llama a la funcion que realiza los calculos y devuelve un array con la solucion
            document.decodificacionProgramasWhile.n.value = result[0];
            document.decodificacionProgramasWhile.p.value = result[1];
            document.decodificacionProgramasWhile.decodificacionProgramasWhileResult.value = result[2];
        }
        // funcion DECODI con return
        function DECODIReturn(z)
        {
            if (typeof z != 'bigint') { // si z no es de tipo bigint, es un error
                alert("Error. \nEl numero a introducir debe de ser mayor o igual que 0.");
            } else {
                var result = [];
                result[0] = decantorizacionGRec(z,3n,1n); // calcula la primera componente de la solucion
                result[1] = decantorizacionGRec(z,3n,2n) + mayorQue(decantorizacionGRec(z,3n,1n),mayorIndiceCodigo(tratarLinea(DeCodiReturn(decantorizacionGRec(z,3n,3n))))); // segunda componente
                result[2] = DeCodiReturn(decantorizacionGRec(z,3n,3n)); // calcula la tercera componente de la solucion
            }
            return result;
        }
    </script>
</html>